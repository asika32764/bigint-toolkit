function f(n){return n<0n&&(n*=-1n),n}function l(n,t){if(n===0n)return{g:t,x:0n,y:1n};{let{g:r,x:e,y:i}=l(t%n,n);return{g:r,x:i-t/n*e,y:e}}}function u(n,t){if(t<=0n)throw new Error("m must be > 0");const r=n%t;return r<0n?r+t:r}function I(n,t){return u(n,t)}function s(n,t){const r=l(u(n,t),t);if(r.g!==1n)throw new Error("Modular inverse does not exist");return u(r.x,t)}function p(n,t){let r=0n;const e=n.reduce((i,o)=>i*o,1n);for(let i=0;i<n.length;i++){const o=e/n[i];r+=t[i]*s(o,n[i])*o}return r%e}function g(n,t){return t===0n?n:g(t,n%t)}function d(n){return n%2n===1n}function v(n){return!d(n)}function y(n){return f(n)===1n}function x(n,t){return n/g(n,t)*t}function T(...n){return n.reduce((t,r)=>r>t?r:t)}function E(...n){return n.reduce((t,r)=>r<t?r:t)}function S(n,t,r){return(n%r+t%r)%r}function P(n,t,r){return n%r*(t%r)%r}function h(n,t,r){if(r===0n)throw new Error("Cannot modPow with modulus 0");if(t===0n)return 1n;if(n=u(n,r),t<0n)return s(h(n,f(t),r),r);let e=1n;for(;t>0n;){if(n===0n)return 0n;d(t)&&(e=e*n%r),t=t/2n,n=n*n%r}return e}function U(n){return-f(n)}function A(n){let t=n;for(let r=2n;r*r<=n;r++)if(n%r===0n){for(;n%r===0n;)n/=r;t-=t/r}return n>1n&&(t-=t/n),t}function M(n){if(typeof process=="object"&&typeof require=="function"){const{randomBytes:t}=require("crypto");return new Uint8Array(t(n))}else{const t=new Uint8Array(n);return window.crypto.getRandomValues(t),t}}function Z(n,t){if(n>t)throw new Error("Start must be less than end");const r=t-n+1n,e=r.toString(2).length;let i;do{const o=Math.ceil(e/8),c=M(o);let B="0x";c.forEach(q=>{B+=q.toString(16).padStart(2,"0")}),i=BigInt(B)&1n<<BigInt(e)-1n}while(i>r);return n+i}var G=Object.freeze({__proto__:null,abs:f,crt:p,eGcd:l,gcd:g,isEven:v,isOdd:d,isUnit:y,lcm:x,max:T,min:E,mod:I,modAdd:S,modInv:s,modMultiply:P,modPow:h,negate:U,phi:A,random:Z,toZn:u});const V=G;function H(n){return n.length%2!==0&&(n="0"+n),n}function a(n,t=!1){let r=n.toString(16);return t?H(r):r}function N(n){return a(n,!0)}function _(n){const t=n.length/2,r=new Uint8Array(t);for(let e=0,i=0;e<t;e++,i+=2)r[e]=parseInt(n.slice(i,i+2),16);return r}function z(n,t=!0){if(n<0n&&t){const e=1n<<(BigInt(n.toString(2).length)/8n+1n)*8n;n+=e}return _(N(n))}function j(n){const t=n.startsWith("-");t&&(n=n.substring(1));let r=BigInt("0x"+n);return t?-r:r}function C(n,t=10){if(typeof n=="bigint")return n;if(typeof n=="number"||t===10)return BigInt(n);if(t===16)return j(n);{let r=0n;for(let e=0;e<n.length;e++){const i=parseInt(n[e],t);if(isNaN(i))throw new Error("Invalid character for base: "+t);r=r*BigInt(t)+BigInt(i)}return r}}function w(n,t=!0){let r=0n;const e=t&&(n[0]&128)!==0;if(e){for(let o=0;o<n.length;o++)n[o]=~n[o]&255;let i=1;for(let o=n.length-1;o>=0&&i>0;o--){const c=n[o]+i;n[o]=c&255,i=c>>8}}for(let i=0;i<n.length;i++)r=(r<<8n)+BigInt(n[i]);return e?-r:r}function O(n){return w(n,!1)}function L(n,t=!1){return a(w(n,t))}function R(n){return a(O(n))}export{V as BigMath,f as abs,a as bigintToHex,N as bigintToHexPadZero,z as bigintToUint8,p as crt,l as eGcd,g as gcd,H as hexPadZero,j as hexToBigint,_ as hexToUint8,v as isEven,d as isOdd,y as isUnit,x as lcm,T as max,E as min,I as mod,S as modAdd,s as modInv,P as modMultiply,h as modPow,U as negate,A as phi,Z as random,M as randomBytes,C as toBigint,u as toZn,w as uint8ToBigint,O as uint8ToBigintPositive,L as uint8ToHex,R as uint8ToHexPositive};
//# sourceMappingURL=bigint-toolkit.es.min.js.map
