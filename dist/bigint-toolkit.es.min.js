function f(n){return n<0n&&(n*=-1n),n}function l(n,t){if(n===0n)return{g:t,x:0n,y:1n};{let{g:r,x:i,y:e}=l(t%n,n);return{g:r,x:e-t/n*i,y:i}}}function u(n,t){if(t<=0n)throw new Error("m must be > 0");const r=n%t;return r<0n?r+t:r}function I(n,t){return u(n,t)}function g(n,t){const r=l(u(n,t),t);if(r.g!==1n)throw new Error("Modular inverse does not exist");return u(r.x,t)}function y(n,t){let r=0n;const i=n.reduce((e,o)=>e*o,1n);for(let e=0;e<n.length;e++){const o=i/n[e];r+=t[e]*g(o,n[e])*o}return r%i}function s(n,t){return t===0n?n:s(t,n%t)}function d(n){return n%2n===1n}function v(n){return!d(n)}function p(n){return f(n)===1n}function T(n,t){return n/s(n,t)*t}function U(...n){return n.reduce((t,r)=>r>t?r:t)}function x(...n){return n.reduce((t,r)=>r<t?r:t)}function E(n,t,r){return(n%r+t%r)%r}function A(n,t,r){return n%r*(t%r)%r}function h(n,t,r){if(r===0n)throw new Error("Cannot modPow with modulus 0");if(t===0n)return 1n;if(n=u(n,r),t<0n)return g(h(n,f(t),r),r);let i=1n;for(;t>0n;){if(n===0n)return 0n;d(t)&&(i=i*n%r),t=t/2n,n=n*n%r}return i}function S(n){return-f(n)}function N(n){let t=n;for(let r=2n;r*r<=n;r++)if(n%r===0n){for(;n%r===0n;)n/=r;t-=t/r}return n>1n&&(t-=t/n),t}function M(n){if(typeof process=="object"&&typeof require=="function"){const{randomBytes:t}=require("crypto");return new Uint8Array(t(n))}else{const t=new Uint8Array(n);return window.crypto.getRandomValues(t),t}}function O(n,t){if(n>t)throw new Error("Start must be less than end");const r=t-n+1n,i=r.toString(2).length;let e;do{const o=Math.ceil(i/8),c=M(o);let B="0x";c.forEach(W=>{B+=W.toString(16).padStart(2,"0")}),e=BigInt(B)&1n<<BigInt(i)-1n}while(e>r);return n+e}var q=Object.freeze({__proto__:null,abs:f,crt:y,eGcd:l,gcd:s,isEven:v,isOdd:d,isUnit:p,lcm:T,max:U,min:x,mod:I,modAdd:E,modInv:g,modMultiply:A,modPow:h,negate:S,phi:N,random:O,toZn:u});const G=q;function P(n){return n.length%2!==0&&(n="0"+n),n}function a(n,t=!1){let r=n.toString(16);return t?P(r):r}function Z(n){return a(n,!0)}function H(n){const t=n.length/2,r=new Uint8Array(t);for(let i=0,e=0;i<t;i++,e+=2)r[i]=parseInt(n.slice(e,e+2),16);return r}function L(n,t=!1){if(n<0n)if(t){const i=1n<<(BigInt(n.toString(2).length)/8n+1n)*8n;n+=i}else throw new Error("BigInt should larger than 0 to convert to Uint8Array");return H(Z(n))}function V(n){return new Uint8Array(n)}function _(n){const t=n.startsWith("-");t&&(n=n.substring(1));let r=BigInt("0x"+n);return t?-r:r}function b(n,t=10){if(typeof n=="bigint")return n;if(typeof n=="number"||t===10)return BigInt(n);if(t===16)return _(n);{let r=0n;for(let i=0;i<n.length;i++){const e=parseInt(n[i],t);if(isNaN(e))throw new Error("Invalid character for base: "+t);r=r*BigInt(t)+BigInt(e)}return r}}function w(n,t=!1){let r=0n;const i=t&&(n[0]&128)!==0;if(i){for(let o=0;o<n.length;o++)n[o]=~n[o]&255;let e=1;for(let o=n.length-1;o>=0&&e>0;o--){const c=n[o]+e;n[o]=c&255,e=c>>8}}for(let e=0;e<n.length;e++)r=(r<<8n)+BigInt(n[e]);return i?-r:r}function j(n){return w(n,!0)}function z(n){return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}function C(n,t=!1){return a(w(n,t))}function R(n){return a(j(n))}export{G as BigMath,f as abs,a as bigintToHex,Z as bigintToHexPadZero,L as bigintToUint8,V as bufferToUint8,y as crt,l as eGcd,s as gcd,P as hexPadZero,_ as hexToBigint,H as hexToUint8,v as isEven,d as isOdd,p as isUnit,T as lcm,U as max,x as min,I as mod,E as modAdd,g as modInv,A as modMultiply,h as modPow,S as negate,N as phi,O as random,M as randomBytes,b as toBigint,u as toZn,w as uint8ToBigint,j as uint8ToBigintWithNegative,z as uint8ToBuffer,C as uint8ToHex,R as uint8ToHexWithNegative};
//# sourceMappingURL=bigint-toolkit.es.min.js.map
