function f(n){return n<0n&&(n*=-1n),n}function l(n,t){if(n===0n)return{g:t,x:0n,y:1n};{let{g:r,x:i,y:e}=l(t%n,n);return{g:r,x:e-t/n*i,y:i}}}function u(n,t){if(t<=0n)throw new Error("m must be > 0");const r=n%t;return r<0n?r+t:r}function B(n,t){return u(n,t)}function g(n,t){const r=l(u(n,t),t);if(r.g!==1n)throw new Error("Modular inverse does not exist");return u(r.x,t)}function y(n,t){let r=BigInt(0);const i=n.reduce((e,o)=>e*o,BigInt(1));for(let e=0;e<n.length;e++){const o=i/n[e];r+=t[e]*g(o,n[e])*o}return r%i}function s(n,t){return t===0n?n:s(t,n%t)}function d(n){return n%2n===1n}function p(n){return!d(n)}function v(n){return f(n)===1n}function A(n,t){return n/s(n,t)*t}function x(...n){return n.reduce((t,r)=>r>t?r:t)}function E(...n){return n.reduce((t,r)=>r<t?r:t)}function S(n,t,r){return(n%r+t%r)%r}function U(n,t,r){return n%r*(t%r)%r}function h(n,t,r){if(r===0n)throw new Error("Cannot modPow with modulus 0");if(t===0n)return 1n;if(n=u(n,r),t<0n)return g(h(n,f(t),r),r);let i=1n;for(;t>0n;){if(n===0n)return 0n;d(t)&&(i=i*n%r),t=t/2n,n=n*n%r}return i}function N(n){return-f(n)}function M(n){let t=n;for(let r=2n;r*r<=n;r++)if(n%r===0n){for(;n%r===0n;)n/=r;t-=t/r}return n>1n&&(t-=t/n),t}function P(n){if(typeof process=="object"&&typeof require=="function"){const{randomBytes:t}=require("crypto");return new Uint8Array(t(n))}else{const t=new Uint8Array(n);return window.crypto.getRandomValues(t),t}}function Z(n,t){if(n>t)throw new Error("Start must be less than end");const r=t-n+1n,i=r.toString(2).length;let e;do{const o=Math.ceil(i/8),c=P(o);let w="0x";c.forEach(G=>{w+=G.toString(16).padStart(2,"0")}),e=BigInt(w)&1n<<BigInt(i)-1n}while(e>r);return n+e}var V=Object.freeze({__proto__:null,abs:f,crt:y,eGcd:l,gcd:s,isEven:p,isOdd:d,isUnit:v,lcm:A,max:x,min:E,mod:B,modAdd:S,modInv:g,modMultiply:U,modPow:h,negate:N,phi:M,random:Z,toZn:u});const z=V;function H(n){return n.length%2!==0&&(n="0"+n),n}function a(n,t=!1){let r=n.toString(16);return t?H(r):r}function _(n){return a(n,!0)}function j(n){const t=n.length/2,r=new Uint8Array(t);for(let i=0,e=0;i<t;i++,e+=2)r[i]=parseInt(n.slice(e,e+2),16);return r}function C(n,t=!0){if(n<0n&&t){const i=1n<<(BigInt(n.toString(2).length)/8n+1n)*8n;n+=i}return j(_(n))}function O(n){const t=n.startsWith("-");t&&(n=n.substring(1));let r=BigInt("0x"+n);return t?-r:r}function L(n,t=10){if(typeof n=="bigint")return n;if(typeof n=="number"||t===10)return BigInt(n);if(t===16)return O(n);{let r=0n;for(let i=0;i<n.length;i++){const e=parseInt(n[i],t);if(isNaN(e))throw new Error("Invalid character for base: "+t);r=r*BigInt(t)+BigInt(e)}return r}}function I(n,t=!0){let r=0n;const i=t&&(n[0]&128)!==0;if(i){for(let o=0;o<n.length;o++)n[o]=~n[o]&255;let e=1;for(let o=n.length-1;o>=0&&e>0;o--){const c=n[o]+e;n[o]=c&255,e=c>>8}}for(let e=0;e<n.length;e++)r=(r<<8n)+BigInt(n[e]);return i?-r:r}function q(n){return I(n,!1)}function R(n,t=!1){return a(I(n,t))}function W(n){return a(q(n))}export{z as BigMath,f as abs,a as bigInt2Hex,_ as bigInt2HexPadZero,C as bigInt2Uint8Array,y as crt,l as eGcd,s as gcd,O as hex2BigInt,j as hex2Uint8Array,H as hexPadZero,p as isEven,d as isOdd,v as isUnit,A as lcm,x as max,E as min,B as mod,S as modAdd,g as modInv,U as modMultiply,h as modPow,N as negate,M as phi,Z as random,P as randomBytes,L as toBigInt,u as toZn,I as uint8Array2BigInt,q as uint8Array2BigIntIgnoreNegative,R as uint8Array2Hex,W as uint8Array2HexIgnoreNegative};
//# sourceMappingURL=bigint-toolkit.es.min.js.map
