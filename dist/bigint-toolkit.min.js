function f(n){return n<0n&&(n*=-1n),n}function c(n,t){if(n===0n)return{g:t,x:0n,y:1n};{let{g:r,x:e,y:i}=c(t%n,n);return{g:r,x:i-t/n*e,y:e}}}function u(n,t){if(t<=0n)throw new Error("m must be > 0");const r=n%t;return r<0n?r+t:r}function w(n,t){return u(n,t)}function l(n,t){const r=c(u(n,t),t);if(r.g!==1n)throw new Error("Modular inverse does not exist");return u(r.x,t)}function I(n,t){let r=BigInt(0);const e=n.reduce((i,o)=>i*o,BigInt(1));for(let i=0;i<n.length;i++){const o=e/n[i];r+=t[i]*l(o,n[i])*o}return r%e}function g(n,t){return t===0n?n:g(t,n%t)}function s(n){return n%2n===1n}function B(n){return!s(n)}function y(n){return f(n)===1n}function p(n,t){return n/g(n,t)*t}function v(...n){return n.reduce((t,r)=>r>t?r:t)}function A(...n){return n.reduce((t,r)=>r<t?r:t)}function x(n,t,r){return(n%r+t%r)%r}function E(n,t,r){return n%r*(t%r)%r}function d(n,t,r){if(r===0n)throw new Error("Cannot modPow with modulus 0");if(t===0n)return 1n;if(n=u(n,r),t<0n)return l(d(n,f(t),r),r);let e=1n;for(;t>0n;){if(n===0n)return 0n;s(t)&&(e=e*n%r),t=t/2n,n=n*n%r}return e}function S(n){return-f(n)}function U(n){let t=n;for(let r=2n;r*r<=n;r++)if(n%r===0n){for(;n%r===0n;)n/=r;t-=t/r}return n>1n&&(t-=t/n),t}function M(n){if(typeof process=="object"&&typeof require=="function"){const{randomBytes:t}=require("crypto");return new Uint8Array(t(n))}else{const t=new Uint8Array(n);return window.crypto.getRandomValues(t),t}}function P(n,t){if(n>t)throw new Error("Start must be less than end");const r=t-n+1n,e=r.toString(2).length;let i;do{const o=Math.ceil(e/8),O=M(o);let h="0x";O.forEach(q=>{h+=q.toString(16).padStart(2,"0")}),i=BigInt(h)&1n<<BigInt(e)-1n}while(i>r);return n+i}var G=Object.freeze({__proto__:null,abs:f,crt:I,eGcd:c,gcd:g,isEven:B,isOdd:s,isUnit:y,lcm:p,max:v,min:A,mod:w,modAdd:x,modInv:l,modMultiply:E,modPow:d,negate:S,phi:U,random:P,toZn:u});const V=G;function Z(n){return n.length%2!==0&&(n="0"+n),n}function a(n,t=!1){let r=n.toString(16);return t?Z(r):r}function N(n){return a(n,!0)}function _(n){const t=n.length/2,r=new Uint8Array(t);for(let e=0,i=0;e<t;e++,i+=2)r[e]=parseInt(n.slice(i,i+2),16);return r}function z(n,t=!0){if(n<0n&&t){const e=1n<<(BigInt(n.toString(2).length)/8n+1n)*8n;n+=e}return _(N(n))}function j(n){const t=n.startsWith("-");t&&(n=n.substring(1));let r=BigInt("0x"+n);return t?-r:r}function C(n,t=10){if(typeof n=="bigint")return n;if(typeof n=="number"||t===10)return BigInt(n);if(t===16)return j(n);{let r=0n;for(let e=0;e<n.length;e++){const i=parseInt(n[e],t);if(isNaN(i))throw new Error("Invalid character for base: "+t);r=r*BigInt(t)+BigInt(i)}return r}}function H(n){let t=0n;const r=(n[0]&128)!==0;if(r){for(let i=0;i<n.length;i++)n[i]=~n[i]&255;let e=1;for(let i=n.length-1;i>=0&&e>0;i--){const o=n[i]+e;n[i]=o&255,e=o>>8}}for(let e=0;e<n.length;e++)t=(t<<8n)+BigInt(n[e]);return r?-t:t}function L(n){return a(H(n))}export{V as BigMath,f as abs,a as bigInt2Hex,N as bigInt2HexPadZero,z as bigInt2Uint8Array,I as crt,c as eGcd,g as gcd,j as hex2BigInt,_ as hex2Uint8Array,Z as hexPadZero,B as isEven,s as isOdd,y as isUnit,p as lcm,v as max,A as min,w as mod,x as modAdd,l as modInv,E as modMultiply,d as modPow,S as negate,U as phi,P as random,M as randomBytes,C as toBigInt,u as toZn,H as uint8Array2BigInt,L as uint8Array2Hex};
//# sourceMappingURL=bigint-toolkit.min.js.map
